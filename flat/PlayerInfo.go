// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package flat

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

type PlayerInfoT struct {
	Physics *PhysicsT `json:"physics"`
	ScoreInfo *ScoreInfoT `json:"score_info"`
	Hitbox *BoxShapeT `json:"hitbox"`
	HitboxOffset *Vector3T `json:"hitbox_offset"`
	AirState AirState `json:"air_state"`
	DodgeTimeout float32 `json:"dodge_timeout"`
	DemolishedTimeout float32 `json:"demolished_timeout"`
	IsSupersonic bool `json:"is_supersonic"`
	IsBot bool `json:"is_bot"`
	Name string `json:"name"`
	Team uint32 `json:"team"`
	Boost uint32 `json:"boost"`
	SpawnId int32 `json:"spawn_id"`
	Accolades []string `json:"accolades"`
	LastInput *ControllerStateT `json:"last_input"`
	LastSpectated bool `json:"last_spectated"`
}

func (t *PlayerInfoT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	physicsOffset := t.Physics.Pack(builder)
	scoreInfoOffset := t.ScoreInfo.Pack(builder)
	hitboxOffset := t.Hitbox.Pack(builder)
	nameOffset := flatbuffers.UOffsetT(0)
	if t.Name != "" {
		nameOffset = builder.CreateString(t.Name)
	}
	accoladesOffset := flatbuffers.UOffsetT(0)
	if t.Accolades != nil {
		accoladesLength := len(t.Accolades)
		accoladesOffsets := make([]flatbuffers.UOffsetT, accoladesLength)
		for j := 0; j < accoladesLength; j++ {
			accoladesOffsets[j] = builder.CreateString(t.Accolades[j])
		}
		PlayerInfoStartAccoladesVector(builder, accoladesLength)
		for j := accoladesLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(accoladesOffsets[j])
		}
		accoladesOffset = builder.EndVector(accoladesLength)
	}
	lastInputOffset := t.LastInput.Pack(builder)
	PlayerInfoStart(builder)
	PlayerInfoAddPhysics(builder, physicsOffset)
	PlayerInfoAddScoreInfo(builder, scoreInfoOffset)
	PlayerInfoAddHitbox(builder, hitboxOffset)
	hitboxOffsetOffset := t.HitboxOffset.Pack(builder)
	PlayerInfoAddHitboxOffset(builder, hitboxOffsetOffset)
	PlayerInfoAddAirState(builder, t.AirState)
	PlayerInfoAddDodgeTimeout(builder, t.DodgeTimeout)
	PlayerInfoAddDemolishedTimeout(builder, t.DemolishedTimeout)
	PlayerInfoAddIsSupersonic(builder, t.IsSupersonic)
	PlayerInfoAddIsBot(builder, t.IsBot)
	PlayerInfoAddName(builder, nameOffset)
	PlayerInfoAddTeam(builder, t.Team)
	PlayerInfoAddBoost(builder, t.Boost)
	PlayerInfoAddSpawnId(builder, t.SpawnId)
	PlayerInfoAddAccolades(builder, accoladesOffset)
	PlayerInfoAddLastInput(builder, lastInputOffset)
	PlayerInfoAddLastSpectated(builder, t.LastSpectated)
	return PlayerInfoEnd(builder)
}

func (rcv *PlayerInfo) UnPackTo(t *PlayerInfoT) {
	t.Physics = rcv.Physics(nil).UnPack()
	t.ScoreInfo = rcv.ScoreInfo(nil).UnPack()
	t.Hitbox = rcv.Hitbox(nil).UnPack()
	t.HitboxOffset = rcv.HitboxOffset(nil).UnPack()
	t.AirState = rcv.AirState()
	t.DodgeTimeout = rcv.DodgeTimeout()
	t.DemolishedTimeout = rcv.DemolishedTimeout()
	t.IsSupersonic = rcv.IsSupersonic()
	t.IsBot = rcv.IsBot()
	t.Name = string(rcv.Name())
	t.Team = rcv.Team()
	t.Boost = rcv.Boost()
	t.SpawnId = rcv.SpawnId()
	accoladesLength := rcv.AccoladesLength()
	t.Accolades = make([]string, accoladesLength)
	for j := 0; j < accoladesLength; j++ {
		t.Accolades[j] = string(rcv.Accolades(j))
	}
	t.LastInput = rcv.LastInput(nil).UnPack()
	t.LastSpectated = rcv.LastSpectated()
}

func (rcv *PlayerInfo) UnPack() *PlayerInfoT {
	if rcv == nil {
		return nil
	}
	t := &PlayerInfoT{}
	rcv.UnPackTo(t)
	return t
}

type PlayerInfo struct {
	_tab flatbuffers.Table
}

func GetRootAsPlayerInfo(buf []byte, offset flatbuffers.UOffsetT) *PlayerInfo {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &PlayerInfo{}
	x.Init(buf, n+offset)
	return x
}

func FinishPlayerInfoBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.Finish(offset)
}

func GetSizePrefixedRootAsPlayerInfo(buf []byte, offset flatbuffers.UOffsetT) *PlayerInfo {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &PlayerInfo{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedPlayerInfoBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.FinishSizePrefixed(offset)
}

func (rcv *PlayerInfo) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *PlayerInfo) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *PlayerInfo) Physics(obj *Physics) *Physics {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Physics)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *PlayerInfo) ScoreInfo(obj *ScoreInfo) *ScoreInfo {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(ScoreInfo)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *PlayerInfo) Hitbox(obj *BoxShape) *BoxShape {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BoxShape)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *PlayerInfo) HitboxOffset(obj *Vector3) *Vector3 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(Vector3)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *PlayerInfo) AirState() AirState {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return AirState(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *PlayerInfo) MutateAirState(n AirState) bool {
	return rcv._tab.MutateByteSlot(12, byte(n))
}

/// How long until the bot cannot dodge anymore, -1 while on ground or when airborne for too long after jumping
func (rcv *PlayerInfo) DodgeTimeout() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// How long until the bot cannot dodge anymore, -1 while on ground or when airborne for too long after jumping
func (rcv *PlayerInfo) MutateDodgeTimeout(n float32) bool {
	return rcv._tab.MutateFloat32Slot(14, n)
}

/// How long until the bot is not demolished anymore, -1 if not demolished
func (rcv *PlayerInfo) DemolishedTimeout() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// How long until the bot is not demolished anymore, -1 if not demolished
func (rcv *PlayerInfo) MutateDemolishedTimeout(n float32) bool {
	return rcv._tab.MutateFloat32Slot(16, n)
}

func (rcv *PlayerInfo) IsSupersonic() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *PlayerInfo) MutateIsSupersonic(n bool) bool {
	return rcv._tab.MutateBoolSlot(18, n)
}

func (rcv *PlayerInfo) IsBot() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *PlayerInfo) MutateIsBot(n bool) bool {
	return rcv._tab.MutateBoolSlot(20, n)
}

func (rcv *PlayerInfo) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *PlayerInfo) Team() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *PlayerInfo) MutateTeam(n uint32) bool {
	return rcv._tab.MutateUint32Slot(24, n)
}

func (rcv *PlayerInfo) Boost() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *PlayerInfo) MutateBoost(n uint32) bool {
	return rcv._tab.MutateUint32Slot(26, n)
}

/// In the case where the requested player index is not available, spawnId will help
/// the framework figure out what index was actually assigned to this player instead.
func (rcv *PlayerInfo) SpawnId() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// In the case where the requested player index is not available, spawnId will help
/// the framework figure out what index was actually assigned to this player instead.
func (rcv *PlayerInfo) MutateSpawnId(n int32) bool {
	return rcv._tab.MutateInt32Slot(28, n)
}

/// Notifications the player triggered by some in-game event, such as:
///    Win, Loss, TimePlayed;
///    Shot, Assist, Center, Clear, PoolShot;
///    Goal, AerialGoal, BicycleGoal, BulletGoal, BackwardsGoal, LongGoal, OvertimeGoal, TurtleGoal;
///    AerialHit, BicycleHit, BulletHit, JuggleHit, FirstTouch, BallHit;
///    Save, EpicSave, FreezeSave;
///    HatTrick, Savior, Playmaker, MVP;
///    FastestGoal, SlowestGoal, FurthestGoal, OwnGoal;
///    MostBallTouches, FewestBallTouches, MostBoostPickups, FewestBoostPickups, BoostPickups;
///    CarTouches, Demolition, Demolish;
///    LowFive, HighFive;
/// Clears every tick.
func (rcv *PlayerInfo) Accolades(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *PlayerInfo) AccoladesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Notifications the player triggered by some in-game event, such as:
///    Win, Loss, TimePlayed;
///    Shot, Assist, Center, Clear, PoolShot;
///    Goal, AerialGoal, BicycleGoal, BulletGoal, BackwardsGoal, LongGoal, OvertimeGoal, TurtleGoal;
///    AerialHit, BicycleHit, BulletHit, JuggleHit, FirstTouch, BallHit;
///    Save, EpicSave, FreezeSave;
///    HatTrick, Savior, Playmaker, MVP;
///    FastestGoal, SlowestGoal, FurthestGoal, OwnGoal;
///    MostBallTouches, FewestBallTouches, MostBoostPickups, FewestBoostPickups, BoostPickups;
///    CarTouches, Demolition, Demolish;
///    LowFive, HighFive;
/// Clears every tick.
/// The last known controller input from this player
func (rcv *PlayerInfo) LastInput(obj *ControllerState) *ControllerState {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(ControllerState)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

/// The last known controller input from this player
/// If the player was the last one to be watched by a spectator
func (rcv *PlayerInfo) LastSpectated() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// If the player was the last one to be watched by a spectator
func (rcv *PlayerInfo) MutateLastSpectated(n bool) bool {
	return rcv._tab.MutateBoolSlot(34, n)
}

func PlayerInfoStart(builder *flatbuffers.Builder) {
	builder.StartObject(16)
}
func PlayerInfoAddPhysics(builder *flatbuffers.Builder, physics flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(physics), 0)
}
func PlayerInfoAddScoreInfo(builder *flatbuffers.Builder, scoreInfo flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(scoreInfo), 0)
}
func PlayerInfoAddHitbox(builder *flatbuffers.Builder, hitbox flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(hitbox), 0)
}
func PlayerInfoAddHitboxOffset(builder *flatbuffers.Builder, hitboxOffset flatbuffers.UOffsetT) {
	builder.PrependStructSlot(3, flatbuffers.UOffsetT(hitboxOffset), 0)
}
func PlayerInfoAddAirState(builder *flatbuffers.Builder, airState AirState) {
	builder.PrependByteSlot(4, byte(airState), 0)
}
func PlayerInfoAddDodgeTimeout(builder *flatbuffers.Builder, dodgeTimeout float32) {
	builder.PrependFloat32Slot(5, dodgeTimeout, 0.0)
}
func PlayerInfoAddDemolishedTimeout(builder *flatbuffers.Builder, demolishedTimeout float32) {
	builder.PrependFloat32Slot(6, demolishedTimeout, 0.0)
}
func PlayerInfoAddIsSupersonic(builder *flatbuffers.Builder, isSupersonic bool) {
	builder.PrependBoolSlot(7, isSupersonic, false)
}
func PlayerInfoAddIsBot(builder *flatbuffers.Builder, isBot bool) {
	builder.PrependBoolSlot(8, isBot, false)
}
func PlayerInfoAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(9, flatbuffers.UOffsetT(name), 0)
}
func PlayerInfoAddTeam(builder *flatbuffers.Builder, team uint32) {
	builder.PrependUint32Slot(10, team, 0)
}
func PlayerInfoAddBoost(builder *flatbuffers.Builder, boost uint32) {
	builder.PrependUint32Slot(11, boost, 0)
}
func PlayerInfoAddSpawnId(builder *flatbuffers.Builder, spawnId int32) {
	builder.PrependInt32Slot(12, spawnId, 0)
}
func PlayerInfoAddAccolades(builder *flatbuffers.Builder, accolades flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(13, flatbuffers.UOffsetT(accolades), 0)
}
func PlayerInfoStartAccoladesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func PlayerInfoAddLastInput(builder *flatbuffers.Builder, lastInput flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(14, flatbuffers.UOffsetT(lastInput), 0)
}
func PlayerInfoAddLastSpectated(builder *flatbuffers.Builder, lastSpectated bool) {
	builder.PrependBoolSlot(15, lastSpectated, false)
}
func PlayerInfoEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
