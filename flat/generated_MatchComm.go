// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package flat

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

type MatchCommT struct {
	Index uint32 `json:"index"`
	Team uint32 `json:"team"`
	TeamOnly bool `json:"team_only"`
	Display string `json:"display"`
	Content []byte `json:"content"`
}

func (t *MatchCommT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	displayOffset := flatbuffers.UOffsetT(0)
	if t.Display != "" {
		displayOffset = builder.CreateString(t.Display)
	}
	contentOffset := flatbuffers.UOffsetT(0)
	if t.Content != nil {
		contentOffset = builder.CreateByteString(t.Content)
	}
	MatchCommStart(builder)
	MatchCommAddIndex(builder, t.Index)
	MatchCommAddTeam(builder, t.Team)
	MatchCommAddTeamOnly(builder, t.TeamOnly)
	MatchCommAddDisplay(builder, displayOffset)
	MatchCommAddContent(builder, contentOffset)
	return MatchCommEnd(builder)
}

func (rcv *MatchComm) UnPackTo(t *MatchCommT) {
	t.Index = rcv.Index()
	t.Team = rcv.Team()
	t.TeamOnly = rcv.TeamOnly()
	t.Display = string(rcv.Display())
	t.Content = rcv.ContentBytes()
}

func (rcv *MatchComm) UnPack() *MatchCommT {
	if rcv == nil {
		return nil
	}
	t := &MatchCommT{}
	rcv.UnPackTo(t)
	return t
}

type MatchComm struct {
	_tab flatbuffers.Table
}

func GetRootAsMatchComm(buf []byte, offset flatbuffers.UOffsetT) *MatchComm {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &MatchComm{}
	x.Init(buf, n+offset)
	return x
}

func FinishMatchCommBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.Finish(offset)
}

func GetSizePrefixedRootAsMatchComm(buf []byte, offset flatbuffers.UOffsetT) *MatchComm {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &MatchComm{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedMatchCommBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.FinishSizePrefixed(offset)
}

func (rcv *MatchComm) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *MatchComm) Table() flatbuffers.Table {
	return rcv._tab
}

/// The index of the player that sent this
func (rcv *MatchComm) Index() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// The index of the player that sent this
func (rcv *MatchComm) MutateIndex(n uint32) bool {
	return rcv._tab.MutateUint32Slot(4, n)
}

/// The team of the player that sent this
func (rcv *MatchComm) Team() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// The team of the player that sent this
func (rcv *MatchComm) MutateTeam(n uint32) bool {
	return rcv._tab.MutateUint32Slot(6, n)
}

/// True if the chat is team only false if everyone can see it
func (rcv *MatchComm) TeamOnly() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// True if the chat is team only false if everyone can see it
func (rcv *MatchComm) MutateTeamOnly(n bool) bool {
	return rcv._tab.MutateBoolSlot(8, n)
}

/// The message that will be displayed on the screen
func (rcv *MatchComm) Display() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The message that will be displayed on the screen
/// The contents of the message
func (rcv *MatchComm) Content(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *MatchComm) ContentLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *MatchComm) ContentBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The contents of the message
func (rcv *MatchComm) MutateContent(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func MatchCommStart(builder *flatbuffers.Builder) {
	builder.StartObject(5)
}
func MatchCommAddIndex(builder *flatbuffers.Builder, index uint32) {
	builder.PrependUint32Slot(0, index, 0)
}
func MatchCommAddTeam(builder *flatbuffers.Builder, team uint32) {
	builder.PrependUint32Slot(1, team, 0)
}
func MatchCommAddTeamOnly(builder *flatbuffers.Builder, teamOnly bool) {
	builder.PrependBoolSlot(2, teamOnly, false)
}
func MatchCommAddDisplay(builder *flatbuffers.Builder, display flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(display), 0)
}
func MatchCommAddContent(builder *flatbuffers.Builder, content flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(content), 0)
}
func MatchCommStartContentVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func MatchCommEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
