// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package flat

import (
	flatbuffers "github.com/google/flatbuffers/go"
	"strconv"
)

/// Messages sent from interfaces to core
type InterfaceMessage byte

const (
	InterfaceMessageNONE               InterfaceMessage = 0
	/// Sent to core to indicate that you want to disconnect.
	InterfaceMessageDisconnectSignal   InterfaceMessage = 1
	/// Starts a new match with a rlbot.toml file
	InterfaceMessageStartCommand       InterfaceMessage = 2
	/// Starts a new match from a MatchConfiguration
	InterfaceMessageMatchConfiguration InterfaceMessage = 3
	/// Sent by bot agents to control their car(s)
	InterfaceMessagePlayerInput        InterfaceMessage = 4
	/// Sent by agents to state-set the game state.
	/// `enable_state_setting` must be true in the MatchConfiguration.
	InterfaceMessageDesiredGameState   InterfaceMessage = 5
	/// Sent by agents to render lines & text in the game.
	InterfaceMessageRenderGroup        InterfaceMessage = 6
	/// Sent by agents to remove a render group.
	InterfaceMessageRemoveRenderGroup  InterfaceMessage = 7
	/// Agents may send a MatchComm packet to communicate with other agents,
	/// core relays this to other agents. May be `team_only` if set.
	InterfaceMessageMatchComm          InterfaceMessage = 8
	/// Should be sent by agents immediately after connecting.
	/// Tells core about who the connection represents and what data they want to receive.
	InterfaceMessageConnectionSettings InterfaceMessage = 9
	/// Ends the match and optionally the RLBotServer too.
	InterfaceMessageStopCommand        InterfaceMessage = 10
	/// Sent by sessions to change the loadout of their cars. Will always work if a loadout was not
	/// specified in match settings and when sent before `InitComplete`. Ignored if state setting
	/// was disabled in the match settings, and a loadout was set in match settings.
	InterfaceMessageSetLoadout         InterfaceMessage = 11
	/// Indicates that the session has finished all initialization and is ready to start receiving
	/// game messages without delay. The match will not start until all sessions have sent this
	/// message.
	InterfaceMessageInitComplete       InterfaceMessage = 12
	/// Requests for a specificed agent to have its ability to render changed.
	/// This changed will then be broadcasted to all current connections.
	/// Does nothing if rendering has been completely disabled.
	InterfaceMessageRenderingStatus    InterfaceMessage = 13
)

var EnumNamesInterfaceMessage = map[InterfaceMessage]string{
	InterfaceMessageNONE:               "NONE",
	InterfaceMessageDisconnectSignal:   "DisconnectSignal",
	InterfaceMessageStartCommand:       "StartCommand",
	InterfaceMessageMatchConfiguration: "MatchConfiguration",
	InterfaceMessagePlayerInput:        "PlayerInput",
	InterfaceMessageDesiredGameState:   "DesiredGameState",
	InterfaceMessageRenderGroup:        "RenderGroup",
	InterfaceMessageRemoveRenderGroup:  "RemoveRenderGroup",
	InterfaceMessageMatchComm:          "MatchComm",
	InterfaceMessageConnectionSettings: "ConnectionSettings",
	InterfaceMessageStopCommand:        "StopCommand",
	InterfaceMessageSetLoadout:         "SetLoadout",
	InterfaceMessageInitComplete:       "InitComplete",
	InterfaceMessageRenderingStatus:    "RenderingStatus",
}

var EnumValuesInterfaceMessage = map[string]InterfaceMessage{
	"NONE":               InterfaceMessageNONE,
	"DisconnectSignal":   InterfaceMessageDisconnectSignal,
	"StartCommand":       InterfaceMessageStartCommand,
	"MatchConfiguration": InterfaceMessageMatchConfiguration,
	"PlayerInput":        InterfaceMessagePlayerInput,
	"DesiredGameState":   InterfaceMessageDesiredGameState,
	"RenderGroup":        InterfaceMessageRenderGroup,
	"RemoveRenderGroup":  InterfaceMessageRemoveRenderGroup,
	"MatchComm":          InterfaceMessageMatchComm,
	"ConnectionSettings": InterfaceMessageConnectionSettings,
	"StopCommand":        InterfaceMessageStopCommand,
	"SetLoadout":         InterfaceMessageSetLoadout,
	"InitComplete":       InterfaceMessageInitComplete,
	"RenderingStatus":    InterfaceMessageRenderingStatus,
}

func (v InterfaceMessage) String() string {
	if s, ok := EnumNamesInterfaceMessage[v]; ok {
		return s
	}
	return "InterfaceMessage(" + strconv.FormatInt(int64(v), 10) + ")"
}

type InterfaceMessageT struct {
	Type InterfaceMessage
	Value interface{}
}

func (t *InterfaceMessageT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	switch t.Type {
	case InterfaceMessageDisconnectSignal:
		return t.Value.(*DisconnectSignalT).Pack(builder)
	case InterfaceMessageStartCommand:
		return t.Value.(*StartCommandT).Pack(builder)
	case InterfaceMessageMatchConfiguration:
		return t.Value.(*MatchConfigurationT).Pack(builder)
	case InterfaceMessagePlayerInput:
		return t.Value.(*PlayerInputT).Pack(builder)
	case InterfaceMessageDesiredGameState:
		return t.Value.(*DesiredGameStateT).Pack(builder)
	case InterfaceMessageRenderGroup:
		return t.Value.(*RenderGroupT).Pack(builder)
	case InterfaceMessageRemoveRenderGroup:
		return t.Value.(*RemoveRenderGroupT).Pack(builder)
	case InterfaceMessageMatchComm:
		return t.Value.(*MatchCommT).Pack(builder)
	case InterfaceMessageConnectionSettings:
		return t.Value.(*ConnectionSettingsT).Pack(builder)
	case InterfaceMessageStopCommand:
		return t.Value.(*StopCommandT).Pack(builder)
	case InterfaceMessageSetLoadout:
		return t.Value.(*SetLoadoutT).Pack(builder)
	case InterfaceMessageInitComplete:
		return t.Value.(*InitCompleteT).Pack(builder)
	case InterfaceMessageRenderingStatus:
		return t.Value.(*RenderingStatusT).Pack(builder)
	}
	return 0
}

func (rcv InterfaceMessage) UnPack(table flatbuffers.Table) *InterfaceMessageT {
	switch rcv {
	case InterfaceMessageDisconnectSignal:
		var x DisconnectSignal
		x.Init(table.Bytes, table.Pos)
		return &InterfaceMessageT{Type: InterfaceMessageDisconnectSignal, Value: x.UnPack()}
	case InterfaceMessageStartCommand:
		var x StartCommand
		x.Init(table.Bytes, table.Pos)
		return &InterfaceMessageT{Type: InterfaceMessageStartCommand, Value: x.UnPack()}
	case InterfaceMessageMatchConfiguration:
		var x MatchConfiguration
		x.Init(table.Bytes, table.Pos)
		return &InterfaceMessageT{Type: InterfaceMessageMatchConfiguration, Value: x.UnPack()}
	case InterfaceMessagePlayerInput:
		var x PlayerInput
		x.Init(table.Bytes, table.Pos)
		return &InterfaceMessageT{Type: InterfaceMessagePlayerInput, Value: x.UnPack()}
	case InterfaceMessageDesiredGameState:
		var x DesiredGameState
		x.Init(table.Bytes, table.Pos)
		return &InterfaceMessageT{Type: InterfaceMessageDesiredGameState, Value: x.UnPack()}
	case InterfaceMessageRenderGroup:
		var x RenderGroup
		x.Init(table.Bytes, table.Pos)
		return &InterfaceMessageT{Type: InterfaceMessageRenderGroup, Value: x.UnPack()}
	case InterfaceMessageRemoveRenderGroup:
		var x RemoveRenderGroup
		x.Init(table.Bytes, table.Pos)
		return &InterfaceMessageT{Type: InterfaceMessageRemoveRenderGroup, Value: x.UnPack()}
	case InterfaceMessageMatchComm:
		var x MatchComm
		x.Init(table.Bytes, table.Pos)
		return &InterfaceMessageT{Type: InterfaceMessageMatchComm, Value: x.UnPack()}
	case InterfaceMessageConnectionSettings:
		var x ConnectionSettings
		x.Init(table.Bytes, table.Pos)
		return &InterfaceMessageT{Type: InterfaceMessageConnectionSettings, Value: x.UnPack()}
	case InterfaceMessageStopCommand:
		var x StopCommand
		x.Init(table.Bytes, table.Pos)
		return &InterfaceMessageT{Type: InterfaceMessageStopCommand, Value: x.UnPack()}
	case InterfaceMessageSetLoadout:
		var x SetLoadout
		x.Init(table.Bytes, table.Pos)
		return &InterfaceMessageT{Type: InterfaceMessageSetLoadout, Value: x.UnPack()}
	case InterfaceMessageInitComplete:
		var x InitComplete
		x.Init(table.Bytes, table.Pos)
		return &InterfaceMessageT{Type: InterfaceMessageInitComplete, Value: x.UnPack()}
	case InterfaceMessageRenderingStatus:
		var x RenderingStatus
		x.Init(table.Bytes, table.Pos)
		return &InterfaceMessageT{Type: InterfaceMessageRenderingStatus, Value: x.UnPack()}
	}
	return nil
}
