// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package flat

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

type PlayerInfoT struct {
	Physics *PhysicsT `json:"physics"`
	ScoreInfo *ScoreInfoT `json:"score_info"`
	Hitbox *BoxShapeT `json:"hitbox"`
	HitboxOffset *Vector3T `json:"hitbox_offset"`
	LatestTouch *TouchT `json:"latest_touch"`
	AirState AirState `json:"air_state"`
	DodgeTimeout float32 `json:"dodge_timeout"`
	DemolishedTimeout float32 `json:"demolished_timeout"`
	IsSupersonic bool `json:"is_supersonic"`
	IsBot bool `json:"is_bot"`
	Name string `json:"name"`
	Team uint32 `json:"team"`
	Boost uint32 `json:"boost"`
	SpawnId int32 `json:"spawn_id"`
	Accolades []string `json:"accolades"`
	LastInput *ControllerStateT `json:"last_input"`
	LastSpectated bool `json:"last_spectated"`
	HasJumped bool `json:"has_jumped"`
	HasDoubleJumped bool `json:"has_double_jumped"`
	HasDodged bool `json:"has_dodged"`
	DodgeElapsed float32 `json:"dodge_elapsed"`
	DodgeDir *Vector2T `json:"dodge_dir"`
}

func (t *PlayerInfoT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	hitboxOffset := t.Hitbox.Pack(builder)
	latestTouchOffset := t.LatestTouch.Pack(builder)
	nameOffset := flatbuffers.UOffsetT(0)
	if t.Name != "" {
		nameOffset = builder.CreateString(t.Name)
	}
	accoladesOffset := flatbuffers.UOffsetT(0)
	if t.Accolades != nil {
		accoladesLength := len(t.Accolades)
		accoladesOffsets := make([]flatbuffers.UOffsetT, accoladesLength)
		for j := 0; j < accoladesLength; j++ {
			accoladesOffsets[j] = builder.CreateString(t.Accolades[j])
		}
		PlayerInfoStartAccoladesVector(builder, accoladesLength)
		for j := accoladesLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(accoladesOffsets[j])
		}
		accoladesOffset = builder.EndVector(accoladesLength)
	}
	PlayerInfoStart(builder)
	physicsOffset := t.Physics.Pack(builder)
	PlayerInfoAddPhysics(builder, physicsOffset)
	scoreInfoOffset := t.ScoreInfo.Pack(builder)
	PlayerInfoAddScoreInfo(builder, scoreInfoOffset)
	PlayerInfoAddHitbox(builder, hitboxOffset)
	hitboxOffsetOffset := t.HitboxOffset.Pack(builder)
	PlayerInfoAddHitboxOffset(builder, hitboxOffsetOffset)
	PlayerInfoAddLatestTouch(builder, latestTouchOffset)
	PlayerInfoAddAirState(builder, t.AirState)
	PlayerInfoAddDodgeTimeout(builder, t.DodgeTimeout)
	PlayerInfoAddDemolishedTimeout(builder, t.DemolishedTimeout)
	PlayerInfoAddIsSupersonic(builder, t.IsSupersonic)
	PlayerInfoAddIsBot(builder, t.IsBot)
	PlayerInfoAddName(builder, nameOffset)
	PlayerInfoAddTeam(builder, t.Team)
	PlayerInfoAddBoost(builder, t.Boost)
	PlayerInfoAddSpawnId(builder, t.SpawnId)
	PlayerInfoAddAccolades(builder, accoladesOffset)
	lastInputOffset := t.LastInput.Pack(builder)
	PlayerInfoAddLastInput(builder, lastInputOffset)
	PlayerInfoAddLastSpectated(builder, t.LastSpectated)
	PlayerInfoAddHasJumped(builder, t.HasJumped)
	PlayerInfoAddHasDoubleJumped(builder, t.HasDoubleJumped)
	PlayerInfoAddHasDodged(builder, t.HasDodged)
	PlayerInfoAddDodgeElapsed(builder, t.DodgeElapsed)
	dodgeDirOffset := t.DodgeDir.Pack(builder)
	PlayerInfoAddDodgeDir(builder, dodgeDirOffset)
	return PlayerInfoEnd(builder)
}

func (rcv *PlayerInfo) UnPackTo(t *PlayerInfoT) {
	t.Physics = rcv.Physics(nil).UnPack()
	t.ScoreInfo = rcv.ScoreInfo(nil).UnPack()
	t.Hitbox = rcv.Hitbox(nil).UnPack()
	t.HitboxOffset = rcv.HitboxOffset(nil).UnPack()
	t.LatestTouch = rcv.LatestTouch(nil).UnPack()
	t.AirState = rcv.AirState()
	t.DodgeTimeout = rcv.DodgeTimeout()
	t.DemolishedTimeout = rcv.DemolishedTimeout()
	t.IsSupersonic = rcv.IsSupersonic()
	t.IsBot = rcv.IsBot()
	t.Name = string(rcv.Name())
	t.Team = rcv.Team()
	t.Boost = rcv.Boost()
	t.SpawnId = rcv.SpawnId()
	accoladesLength := rcv.AccoladesLength()
	t.Accolades = make([]string, accoladesLength)
	for j := 0; j < accoladesLength; j++ {
		t.Accolades[j] = string(rcv.Accolades(j))
	}
	t.LastInput = rcv.LastInput(nil).UnPack()
	t.LastSpectated = rcv.LastSpectated()
	t.HasJumped = rcv.HasJumped()
	t.HasDoubleJumped = rcv.HasDoubleJumped()
	t.HasDodged = rcv.HasDodged()
	t.DodgeElapsed = rcv.DodgeElapsed()
	t.DodgeDir = rcv.DodgeDir(nil).UnPack()
}

func (rcv *PlayerInfo) UnPack() *PlayerInfoT {
	if rcv == nil {
		return nil
	}
	t := &PlayerInfoT{}
	rcv.UnPackTo(t)
	return t
}

type PlayerInfo struct {
	_tab flatbuffers.Table
}

func GetRootAsPlayerInfo(buf []byte, offset flatbuffers.UOffsetT) *PlayerInfo {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &PlayerInfo{}
	x.Init(buf, n+offset)
	return x
}

func FinishPlayerInfoBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.Finish(offset)
}

func GetSizePrefixedRootAsPlayerInfo(buf []byte, offset flatbuffers.UOffsetT) *PlayerInfo {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &PlayerInfo{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedPlayerInfoBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.FinishSizePrefixed(offset)
}

func (rcv *PlayerInfo) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *PlayerInfo) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *PlayerInfo) Physics(obj *Physics) *Physics {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(Physics)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *PlayerInfo) ScoreInfo(obj *ScoreInfo) *ScoreInfo {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(ScoreInfo)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *PlayerInfo) Hitbox(obj *BoxShape) *BoxShape {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BoxShape)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *PlayerInfo) HitboxOffset(obj *Vector3) *Vector3 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(Vector3)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *PlayerInfo) LatestTouch(obj *Touch) *Touch {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Touch)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *PlayerInfo) AirState() AirState {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return AirState(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *PlayerInfo) MutateAirState(n AirState) bool {
	return rcv._tab.MutateByteSlot(14, byte(n))
}

/// How long until the bot cannot dodge anymore, -1 while on ground or when airborne for too long after jumping
func (rcv *PlayerInfo) DodgeTimeout() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// How long until the bot cannot dodge anymore, -1 while on ground or when airborne for too long after jumping
func (rcv *PlayerInfo) MutateDodgeTimeout(n float32) bool {
	return rcv._tab.MutateFloat32Slot(16, n)
}

/// How long until the bot is not demolished anymore, -1 if not demolished
func (rcv *PlayerInfo) DemolishedTimeout() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// How long until the bot is not demolished anymore, -1 if not demolished
func (rcv *PlayerInfo) MutateDemolishedTimeout(n float32) bool {
	return rcv._tab.MutateFloat32Slot(18, n)
}

func (rcv *PlayerInfo) IsSupersonic() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *PlayerInfo) MutateIsSupersonic(n bool) bool {
	return rcv._tab.MutateBoolSlot(20, n)
}

func (rcv *PlayerInfo) IsBot() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *PlayerInfo) MutateIsBot(n bool) bool {
	return rcv._tab.MutateBoolSlot(22, n)
}

func (rcv *PlayerInfo) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *PlayerInfo) Team() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *PlayerInfo) MutateTeam(n uint32) bool {
	return rcv._tab.MutateUint32Slot(26, n)
}

func (rcv *PlayerInfo) Boost() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *PlayerInfo) MutateBoost(n uint32) bool {
	return rcv._tab.MutateUint32Slot(28, n)
}

func (rcv *PlayerInfo) SpawnId() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *PlayerInfo) MutateSpawnId(n int32) bool {
	return rcv._tab.MutateInt32Slot(30, n)
}

/// Notifications the player triggered by some in-game event, such as:
///    Win, Loss, TimePlayed;
///    Shot, Assist, Center, Clear, PoolShot;
///    Goal, AerialGoal, BicycleGoal, BulletGoal, BackwardsGoal, LongGoal, OvertimeGoal, TurtleGoal;
///    AerialHit, BicycleHit, BulletHit, JuggleHit, FirstTouch, BallHit;
///    Save, EpicSave, FreezeSave;
///    HatTrick, Savior, Playmaker, MVP;
///    FastestGoal, SlowestGoal, FurthestGoal, OwnGoal;
///    MostBallTouches, FewestBallTouches, MostBoostPickups, FewestBoostPickups, BoostPickups;
///    CarTouches, Demolition, Demolish;
///    LowFive, HighFive;
/// Clears every tick.
func (rcv *PlayerInfo) Accolades(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *PlayerInfo) AccoladesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Notifications the player triggered by some in-game event, such as:
///    Win, Loss, TimePlayed;
///    Shot, Assist, Center, Clear, PoolShot;
///    Goal, AerialGoal, BicycleGoal, BulletGoal, BackwardsGoal, LongGoal, OvertimeGoal, TurtleGoal;
///    AerialHit, BicycleHit, BulletHit, JuggleHit, FirstTouch, BallHit;
///    Save, EpicSave, FreezeSave;
///    HatTrick, Savior, Playmaker, MVP;
///    FastestGoal, SlowestGoal, FurthestGoal, OwnGoal;
///    MostBallTouches, FewestBallTouches, MostBoostPickups, FewestBoostPickups, BoostPickups;
///    CarTouches, Demolition, Demolish;
///    LowFive, HighFive;
/// Clears every tick.
/// The last known controller input from this player
func (rcv *PlayerInfo) LastInput(obj *ControllerState) *ControllerState {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(ControllerState)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

/// The last known controller input from this player
/// If the player was the last one to be watched by a spectator
func (rcv *PlayerInfo) LastSpectated() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// If the player was the last one to be watched by a spectator
func (rcv *PlayerInfo) MutateLastSpectated(n bool) bool {
	return rcv._tab.MutateBoolSlot(36, n)
}

func (rcv *PlayerInfo) HasJumped() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *PlayerInfo) MutateHasJumped(n bool) bool {
	return rcv._tab.MutateBoolSlot(38, n)
}

func (rcv *PlayerInfo) HasDoubleJumped() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *PlayerInfo) MutateHasDoubleJumped(n bool) bool {
	return rcv._tab.MutateBoolSlot(40, n)
}

func (rcv *PlayerInfo) HasDodged() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *PlayerInfo) MutateHasDodged(n bool) bool {
	return rcv._tab.MutateBoolSlot(42, n)
}

/// The time in seconds since the last dodge was initiated.
/// Resets to 0 when the player lands on the ground.
func (rcv *PlayerInfo) DodgeElapsed() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The time in seconds since the last dodge was initiated.
/// Resets to 0 when the player lands on the ground.
func (rcv *PlayerInfo) MutateDodgeElapsed(n float32) bool {
	return rcv._tab.MutateFloat32Slot(44, n)
}

func (rcv *PlayerInfo) DodgeDir(obj *Vector2) *Vector2 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(Vector2)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func PlayerInfoStart(builder *flatbuffers.Builder) {
	builder.StartObject(22)
}
func PlayerInfoAddPhysics(builder *flatbuffers.Builder, physics flatbuffers.UOffsetT) {
	builder.PrependStructSlot(0, flatbuffers.UOffsetT(physics), 0)
}
func PlayerInfoAddScoreInfo(builder *flatbuffers.Builder, scoreInfo flatbuffers.UOffsetT) {
	builder.PrependStructSlot(1, flatbuffers.UOffsetT(scoreInfo), 0)
}
func PlayerInfoAddHitbox(builder *flatbuffers.Builder, hitbox flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(hitbox), 0)
}
func PlayerInfoAddHitboxOffset(builder *flatbuffers.Builder, hitboxOffset flatbuffers.UOffsetT) {
	builder.PrependStructSlot(3, flatbuffers.UOffsetT(hitboxOffset), 0)
}
func PlayerInfoAddLatestTouch(builder *flatbuffers.Builder, latestTouch flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(latestTouch), 0)
}
func PlayerInfoAddAirState(builder *flatbuffers.Builder, airState AirState) {
	builder.PrependByteSlot(5, byte(airState), 0)
}
func PlayerInfoAddDodgeTimeout(builder *flatbuffers.Builder, dodgeTimeout float32) {
	builder.PrependFloat32Slot(6, dodgeTimeout, 0.0)
}
func PlayerInfoAddDemolishedTimeout(builder *flatbuffers.Builder, demolishedTimeout float32) {
	builder.PrependFloat32Slot(7, demolishedTimeout, 0.0)
}
func PlayerInfoAddIsSupersonic(builder *flatbuffers.Builder, isSupersonic bool) {
	builder.PrependBoolSlot(8, isSupersonic, false)
}
func PlayerInfoAddIsBot(builder *flatbuffers.Builder, isBot bool) {
	builder.PrependBoolSlot(9, isBot, false)
}
func PlayerInfoAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(10, flatbuffers.UOffsetT(name), 0)
}
func PlayerInfoAddTeam(builder *flatbuffers.Builder, team uint32) {
	builder.PrependUint32Slot(11, team, 0)
}
func PlayerInfoAddBoost(builder *flatbuffers.Builder, boost uint32) {
	builder.PrependUint32Slot(12, boost, 0)
}
func PlayerInfoAddSpawnId(builder *flatbuffers.Builder, spawnId int32) {
	builder.PrependInt32Slot(13, spawnId, 0)
}
func PlayerInfoAddAccolades(builder *flatbuffers.Builder, accolades flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(14, flatbuffers.UOffsetT(accolades), 0)
}
func PlayerInfoStartAccoladesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func PlayerInfoAddLastInput(builder *flatbuffers.Builder, lastInput flatbuffers.UOffsetT) {
	builder.PrependStructSlot(15, flatbuffers.UOffsetT(lastInput), 0)
}
func PlayerInfoAddLastSpectated(builder *flatbuffers.Builder, lastSpectated bool) {
	builder.PrependBoolSlot(16, lastSpectated, false)
}
func PlayerInfoAddHasJumped(builder *flatbuffers.Builder, hasJumped bool) {
	builder.PrependBoolSlot(17, hasJumped, false)
}
func PlayerInfoAddHasDoubleJumped(builder *flatbuffers.Builder, hasDoubleJumped bool) {
	builder.PrependBoolSlot(18, hasDoubleJumped, false)
}
func PlayerInfoAddHasDodged(builder *flatbuffers.Builder, hasDodged bool) {
	builder.PrependBoolSlot(19, hasDodged, false)
}
func PlayerInfoAddDodgeElapsed(builder *flatbuffers.Builder, dodgeElapsed float32) {
	builder.PrependFloat32Slot(20, dodgeElapsed, 0.0)
}
func PlayerInfoAddDodgeDir(builder *flatbuffers.Builder, dodgeDir flatbuffers.UOffsetT) {
	builder.PrependStructSlot(21, flatbuffers.UOffsetT(dodgeDir), 0)
}
func PlayerInfoEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
