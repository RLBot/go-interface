// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package flat

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

type ControllerStateT struct {
	Throttle float32 `json:"throttle"`
	Steer float32 `json:"steer"`
	Pitch float32 `json:"pitch"`
	Yaw float32 `json:"yaw"`
	Roll float32 `json:"roll"`
	Jump bool `json:"jump"`
	Boost bool `json:"boost"`
	Handbrake bool `json:"handbrake"`
	UseItem bool `json:"use_item"`
}

func (t *ControllerStateT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	ControllerStateStart(builder)
	ControllerStateAddThrottle(builder, t.Throttle)
	ControllerStateAddSteer(builder, t.Steer)
	ControllerStateAddPitch(builder, t.Pitch)
	ControllerStateAddYaw(builder, t.Yaw)
	ControllerStateAddRoll(builder, t.Roll)
	ControllerStateAddJump(builder, t.Jump)
	ControllerStateAddBoost(builder, t.Boost)
	ControllerStateAddHandbrake(builder, t.Handbrake)
	ControllerStateAddUseItem(builder, t.UseItem)
	return ControllerStateEnd(builder)
}

func (rcv *ControllerState) UnPackTo(t *ControllerStateT) {
	t.Throttle = rcv.Throttle()
	t.Steer = rcv.Steer()
	t.Pitch = rcv.Pitch()
	t.Yaw = rcv.Yaw()
	t.Roll = rcv.Roll()
	t.Jump = rcv.Jump()
	t.Boost = rcv.Boost()
	t.Handbrake = rcv.Handbrake()
	t.UseItem = rcv.UseItem()
}

func (rcv *ControllerState) UnPack() *ControllerStateT {
	if rcv == nil {
		return nil
	}
	t := &ControllerStateT{}
	rcv.UnPackTo(t)
	return t
}

type ControllerState struct {
	_tab flatbuffers.Table
}

func GetRootAsControllerState(buf []byte, offset flatbuffers.UOffsetT) *ControllerState {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ControllerState{}
	x.Init(buf, n+offset)
	return x
}

func FinishControllerStateBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.Finish(offset)
}

func GetSizePrefixedRootAsControllerState(buf []byte, offset flatbuffers.UOffsetT) *ControllerState {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ControllerState{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedControllerStateBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.FinishSizePrefixed(offset)
}

func (rcv *ControllerState) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ControllerState) Table() flatbuffers.Table {
	return rcv._tab
}

/// -1 for full reverse, 1 for full forward
func (rcv *ControllerState) Throttle() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// -1 for full reverse, 1 for full forward
func (rcv *ControllerState) MutateThrottle(n float32) bool {
	return rcv._tab.MutateFloat32Slot(4, n)
}

/// -1 for full left, 1 for full right
func (rcv *ControllerState) Steer() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// -1 for full left, 1 for full right
func (rcv *ControllerState) MutateSteer(n float32) bool {
	return rcv._tab.MutateFloat32Slot(6, n)
}

/// -1 for nose down, 1 for nose up
func (rcv *ControllerState) Pitch() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// -1 for nose down, 1 for nose up
func (rcv *ControllerState) MutatePitch(n float32) bool {
	return rcv._tab.MutateFloat32Slot(8, n)
}

/// -1 for full left, 1 for full right
func (rcv *ControllerState) Yaw() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// -1 for full left, 1 for full right
func (rcv *ControllerState) MutateYaw(n float32) bool {
	return rcv._tab.MutateFloat32Slot(10, n)
}

/// -1 for roll left, 1 for roll right
func (rcv *ControllerState) Roll() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// -1 for roll left, 1 for roll right
func (rcv *ControllerState) MutateRoll(n float32) bool {
	return rcv._tab.MutateFloat32Slot(12, n)
}

/// true if you want to press the jump button
func (rcv *ControllerState) Jump() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// true if you want to press the jump button
func (rcv *ControllerState) MutateJump(n bool) bool {
	return rcv._tab.MutateBoolSlot(14, n)
}

/// true if you want to press the boost button
func (rcv *ControllerState) Boost() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// true if you want to press the boost button
func (rcv *ControllerState) MutateBoost(n bool) bool {
	return rcv._tab.MutateBoolSlot(16, n)
}

/// true if you want to press the handbrake button
func (rcv *ControllerState) Handbrake() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// true if you want to press the handbrake button
func (rcv *ControllerState) MutateHandbrake(n bool) bool {
	return rcv._tab.MutateBoolSlot(18, n)
}

/// true if you want to press the 'use item' button, used in rumble etc.
func (rcv *ControllerState) UseItem() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// true if you want to press the 'use item' button, used in rumble etc.
func (rcv *ControllerState) MutateUseItem(n bool) bool {
	return rcv._tab.MutateBoolSlot(20, n)
}

func ControllerStateStart(builder *flatbuffers.Builder) {
	builder.StartObject(9)
}
func ControllerStateAddThrottle(builder *flatbuffers.Builder, throttle float32) {
	builder.PrependFloat32Slot(0, throttle, 0.0)
}
func ControllerStateAddSteer(builder *flatbuffers.Builder, steer float32) {
	builder.PrependFloat32Slot(1, steer, 0.0)
}
func ControllerStateAddPitch(builder *flatbuffers.Builder, pitch float32) {
	builder.PrependFloat32Slot(2, pitch, 0.0)
}
func ControllerStateAddYaw(builder *flatbuffers.Builder, yaw float32) {
	builder.PrependFloat32Slot(3, yaw, 0.0)
}
func ControllerStateAddRoll(builder *flatbuffers.Builder, roll float32) {
	builder.PrependFloat32Slot(4, roll, 0.0)
}
func ControllerStateAddJump(builder *flatbuffers.Builder, jump bool) {
	builder.PrependBoolSlot(5, jump, false)
}
func ControllerStateAddBoost(builder *flatbuffers.Builder, boost bool) {
	builder.PrependBoolSlot(6, boost, false)
}
func ControllerStateAddHandbrake(builder *flatbuffers.Builder, handbrake bool) {
	builder.PrependBoolSlot(7, handbrake, false)
}
func ControllerStateAddUseItem(builder *flatbuffers.Builder, useItem bool) {
	builder.PrependBoolSlot(8, useItem, false)
}
func ControllerStateEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
