// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package flat

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

type GameTickPacketT struct {
	Players []*PlayerInfoT `json:"players"`
	BoostPadStates []*BoostPadStateT `json:"boost_pad_states"`
	Ball *BallInfoT `json:"ball"`
	GameInfo *GameInfoT `json:"game_info"`
	Teams []*TeamInfoT `json:"teams"`
}

func (t *GameTickPacketT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	playersOffset := flatbuffers.UOffsetT(0)
	if t.Players != nil {
		playersLength := len(t.Players)
		playersOffsets := make([]flatbuffers.UOffsetT, playersLength)
		for j := 0; j < playersLength; j++ {
			playersOffsets[j] = t.Players[j].Pack(builder)
		}
		GameTickPacketStartPlayersVector(builder, playersLength)
		for j := playersLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(playersOffsets[j])
		}
		playersOffset = builder.EndVector(playersLength)
	}
	boostPadStatesOffset := flatbuffers.UOffsetT(0)
	if t.BoostPadStates != nil {
		boostPadStatesLength := len(t.BoostPadStates)
		boostPadStatesOffsets := make([]flatbuffers.UOffsetT, boostPadStatesLength)
		for j := 0; j < boostPadStatesLength; j++ {
			boostPadStatesOffsets[j] = t.BoostPadStates[j].Pack(builder)
		}
		GameTickPacketStartBoostPadStatesVector(builder, boostPadStatesLength)
		for j := boostPadStatesLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(boostPadStatesOffsets[j])
		}
		boostPadStatesOffset = builder.EndVector(boostPadStatesLength)
	}
	ballOffset := t.Ball.Pack(builder)
	gameInfoOffset := t.GameInfo.Pack(builder)
	teamsOffset := flatbuffers.UOffsetT(0)
	if t.Teams != nil {
		teamsLength := len(t.Teams)
		teamsOffsets := make([]flatbuffers.UOffsetT, teamsLength)
		for j := 0; j < teamsLength; j++ {
			teamsOffsets[j] = t.Teams[j].Pack(builder)
		}
		GameTickPacketStartTeamsVector(builder, teamsLength)
		for j := teamsLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(teamsOffsets[j])
		}
		teamsOffset = builder.EndVector(teamsLength)
	}
	GameTickPacketStart(builder)
	GameTickPacketAddPlayers(builder, playersOffset)
	GameTickPacketAddBoostPadStates(builder, boostPadStatesOffset)
	GameTickPacketAddBall(builder, ballOffset)
	GameTickPacketAddGameInfo(builder, gameInfoOffset)
	GameTickPacketAddTeams(builder, teamsOffset)
	return GameTickPacketEnd(builder)
}

func (rcv *GameTickPacket) UnPackTo(t *GameTickPacketT) {
	playersLength := rcv.PlayersLength()
	t.Players = make([]*PlayerInfoT, playersLength)
	for j := 0; j < playersLength; j++ {
		x := PlayerInfo{}
		rcv.Players(&x, j)
		t.Players[j] = x.UnPack()
	}
	boostPadStatesLength := rcv.BoostPadStatesLength()
	t.BoostPadStates = make([]*BoostPadStateT, boostPadStatesLength)
	for j := 0; j < boostPadStatesLength; j++ {
		x := BoostPadState{}
		rcv.BoostPadStates(&x, j)
		t.BoostPadStates[j] = x.UnPack()
	}
	t.Ball = rcv.Ball(nil).UnPack()
	t.GameInfo = rcv.GameInfo(nil).UnPack()
	teamsLength := rcv.TeamsLength()
	t.Teams = make([]*TeamInfoT, teamsLength)
	for j := 0; j < teamsLength; j++ {
		x := TeamInfo{}
		rcv.Teams(&x, j)
		t.Teams[j] = x.UnPack()
	}
}

func (rcv *GameTickPacket) UnPack() *GameTickPacketT {
	if rcv == nil {
		return nil
	}
	t := &GameTickPacketT{}
	rcv.UnPackTo(t)
	return t
}

type GameTickPacket struct {
	_tab flatbuffers.Table
}

func GetRootAsGameTickPacket(buf []byte, offset flatbuffers.UOffsetT) *GameTickPacket {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &GameTickPacket{}
	x.Init(buf, n+offset)
	return x
}

func FinishGameTickPacketBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.Finish(offset)
}

func GetSizePrefixedRootAsGameTickPacket(buf []byte, offset flatbuffers.UOffsetT) *GameTickPacket {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &GameTickPacket{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedGameTickPacketBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.FinishSizePrefixed(offset)
}

func (rcv *GameTickPacket) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *GameTickPacket) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *GameTickPacket) Players(obj *PlayerInfo, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *GameTickPacket) PlayersLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *GameTickPacket) BoostPadStates(obj *BoostPadState, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *GameTickPacket) BoostPadStatesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *GameTickPacket) Ball(obj *BallInfo) *BallInfo {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(BallInfo)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *GameTickPacket) GameInfo(obj *GameInfo) *GameInfo {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(GameInfo)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *GameTickPacket) Teams(obj *TeamInfo, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *GameTickPacket) TeamsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func GameTickPacketStart(builder *flatbuffers.Builder) {
	builder.StartObject(5)
}
func GameTickPacketAddPlayers(builder *flatbuffers.Builder, players flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(players), 0)
}
func GameTickPacketStartPlayersVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func GameTickPacketAddBoostPadStates(builder *flatbuffers.Builder, boostPadStates flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(boostPadStates), 0)
}
func GameTickPacketStartBoostPadStatesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func GameTickPacketAddBall(builder *flatbuffers.Builder, ball flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(ball), 0)
}
func GameTickPacketAddGameInfo(builder *flatbuffers.Builder, gameInfo flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(gameInfo), 0)
}
func GameTickPacketAddTeams(builder *flatbuffers.Builder, teams flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(teams), 0)
}
func GameTickPacketStartTeamsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func GameTickPacketEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
